## 웹 이란?
웹이란 무엇이고 어떻게 시작하게 되었으며 현재 우리는 어떤 방식으로 접하고 있을까? 친숙하지만 친숙하지 않은 웹. 알아보자. ㅋ

### 초기의 웹

1993년 웹 서비스에 대해 처음으로 `GUI(Graphics User Interface)` 방식의 UI를 제공하는 브라우저 __**모자익**__ 발표로 편리한 웹 서비스 이용이 가능해지며 대중적인 인터넷 서비스로 발전함.


초기의 웹 서비스는 텍스트 자원들을 연결하는 **하이퍼텍스트** 개념이 다양한 `멀티 미디어 자원(이미지, 비디오 등)`을 연결하는 `하이퍼링크` 개념으로 확장 및 발전되었다. 이전부터 존재했던 정보 검색, 이메일, 파일 전송 등 많은 인터넷 서비스가 웹 기반으로 재구축 되며, 대이터베이스와 같은 정보 시스템과의 연동을 통해 정보검색 포탈과 같은 다양한 서비스들이 개발되며 점차 우리가 알고 있는 웹이 되며 폭발적인 발전을 이뤘다.


### 웹의 발전

1994년 `W3C(World Wide Web Consortium)`이 HTML 표준 등 웹 관련 표준의 개발과 발전을 주도하고 있으며 아직까지도 이어지는 중이다.

2000년대에 들어서며 모바일 환경이 급격히 증가하며 이에 맞춰 웹은 **이동 컴퓨팅, 클라우드 컴퓨팅**과 같은 최신 컴퓨터 기술과 융합하여 모바일 서비스로 진화하며 다양한 응용 서비스 들이 개발되어 오고 있다.


### 웹의 구성 요소

웹은 기본적으로 **인터넷 연결, 웹 브라우저**와 같은 기본 요소가 필요하다. 웹은 기본적으로 `HTTP(HyperText Transfer Protocal`이라는 `TCP`프로토콜을 이용하는 응용프로토콜의 한 종류를 사용한다. HTTP는 텍스트 기반의 통신 규약으로 `요청(Request)`와 `응답(Response)`로 동작한다. 

## 프로토콜
HTTP? TCP? 이게 무슨 댕소린가 할 수 있다.

우리집 땡이도 이해할 정도로 쉽게 설명하자면 `클라이언트(브라우저)`가 필요한 정보를 요청하고 `서버(말그대로 Server)`가 그 요청을 보고 요청한 정보를 준다고 생각하면 된다. 아니 쉽게 설명한다며? 라고 할수 있으니 비유법으로 가겠다.

클라이언트는 손님이다. 어떤 계약을 하거나 주문을 한 사람을 업계에서는 **클라이언트(Client)** 라고 한다. **서버(Server)** 는 서빙하는 사람이라고 생각하면 쉽다. 실제로 여기서 유래 됬다는 소리도 있다. __(아마도 기억안난다.)__ 자 우리가 국밥집에 갔다고 생각하자. 나는 돼지 국밥을 먹고싶다. 그럼 **서빙하는 아주머니(서버)** 에게 요청할 꺼다. 누가? 손놈(클라이언트)인 내가. 서버인 아주머니에게 손놈(클라이언트)(이)가 돼지국밥 하나를 요청한다. 그럼 아주머니(서버)는 돼지 국밥을 가져다 준다. 이 얼마나 쉽게 이해가 되는가? 혹시 여기서 질문이 생길 수 있다. 서버가 요청을 먼저 보내는 일은 없는가? 물론 있을수 있다. 극히 드물지만 이 글을 보고 있는 사람이 고려할 사항은 아니라고 생각된다. 근디 궁금하다? 그럼 안된다고 그냥 생각해라. 국밥집 사장님이 배고플꺼니까 국밥 미리 가져다 주고 주머니에 손넣고 돈 뺴가는 느낌이다.

### HTTP Method(요청의 종류)

HTTP는 다양한 요청 방식을 가지고 있다.

- `GET` : **URL** 로 요청을 전송한다. 평소에 웹에 들어갈때 보내는 요청이라고 생각하면 쉽다.
- `POST` : 유저에게는 보이지 않게 요청을 전송한다. 주로 URL로 인한 변조가 민감하거나, 공유에 필요성이 없을떄 사용한다. (비밀번호, 메세지 등)
- `PUT` : 업로드 할떄 주로 쓰인다. 글이나, 문서, 파일 및 이미지 등 (최근은 보안적인 문제로 인해 안쓰는 추세이다.)
- `DELETE` : 문서나 파일등을 지우라는 요청이다. (위와 같은 이유로 잘 안보인다.)
- `HEAD` : 웹 문서의 **HEAD** 부분만 요청한다. 우리가 HTML작성할때 가장 위에 title, description등을 정의하는 그 HEAD가 맞다. (왜 필요하나? 문서의 편집이나, 업로드 일자, 무결성 검증 등 다양한 이유로 요청한다.)
- `PATCH` : 문서의 일부를 수정하라는 요청이다. 롤 패치와 같은 느낌으로 기억하면 쉬울것이다. 롤대들이여

### HTTP Status Code(응답 상태 코드)

HTTP를 이용해 응답을 전송할떄 그 응답의 상태를 같이 전송하게 되는데, 그 응답의 상태를 정의된 코드들로 보내게 된다. 흔히 접해볼 수 있는 것은 사이트가 존제하지 않을때 `404 (Page not founded)`를 접해보았을 것이다. 이처럼 응답의 성공, 실패여부와 더불어 이유를 설명해 주는 코드가 이 **응답 상태 코드** 이다.

무작정 규칙없이 배치되어있지는 않고 아래와 같은 큰 틀 안에서 XX에서 더 세부적으로 분활된다. 궁금한 예비 코딩 변태는 찾아보는 것도 나쁘지 않다.
[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status]

- `1XX` : 요청이 처리중이고 문제가 없음.
- `2XX` : 요청이 성공적으로 완료 되었음.
- `3XX` : 서버의 위치나 다른 웹으로 연결하기 위해 이쪽 주소로 가라고 알림. **리다이렉션(Redirection)**
- `4XX` : 클라이언트의 요청이 올바르지 않다고 알림. (뭐 없는 주소 찾아온 404도 클라 잘못이니)
- `5XX` : 서버의 문제로 요청이 정상처리 되지 않았음을 알림. (이게 뜨면 개발자 피눈물 흘리는 것)

## 웹 프로그래밍

웹 프로그래밍은 프로그래밍을 통해 웹 페이지를 구성하는 것이다. 쉽게 말하면 이것인데.. 아래의 내용에서 혼동될 수 있을 것 같다.

웹 프로그래밍 크게 직군은 2가지로 나뉜다.

- `프론트엔드` : 유저에게 직접 보이는 즉. 브라우저가 읽고 그릴 코드를 작성한다. (HTML, CSS, Javascript)를 주로 작성한다.
- `백엔드` : 유저가 브라우저를 통해 보낼 요청을 받는 서버와 요청 처리 코드를 구축한다. (다양한 언어를 씀 ㄹㅇ; 귀찮은게 아니라..)

그러니 웹 프로그래밍이라고 웹 페이지를 구성하는 것만을 이야기 하는 것이 아닌 엄청나게 큰 포괄적인 의미를 담고 있다. 알아서 능동적으로 판단할 필요가 있다.

여기서 프론트엔드가 그럼 개꿀따리 아닌가? 할 수 있다. 물론 백엔드보다는 행복할 수 있다. 백엔드는 흔히 말하는 혼모노가 좋아하고, 프론트엔드는 인싸 개발자가 한다는 말도 있을 정도니. 그렇다고 프론트엔드가 완전 개꿀따리는 아닐수 있다.. 왜냐? 다양한 브라우저에서 일괄적인 디자인을 유지해야 하기 때문이다.

### 브라우저
우리가 흔히 아는 브라우저는 크롬(Chrome), 사파리(Safari), 엣지(Edge), 네이버(산업폐기물) 정도 있을 것이다.

브라우저의 역할은 기본적으로 HTML 코드(웹 페이지 코드)를 읽어와서 해석하고 해석한대로 GUI를 그려내는 것을 주로 한다.
근데 이 브라우저들은 서로 다른 회사에서 만든것이다. 물론 그 덕분에 서로 웹 코드를 해석하는 방법도 다르다. 덕분에 크롬과 사피리에서는 버튼이 가운데에 있는데 엣지는 저기 혼자 벽에 박혀 있을 수도 있고, 크롬과 엣지에서 테스트 하면서 코드를 잘 만들었는데 사파리에서는 무슨 똥파리가 되어있을 수도 있는 것이다. 번역하는 방법이 브라우저마다 다르기 떄문에 이를 해결하고 디자인을 일괄성 있게 만드는 것이 중요하고 이가 프론트엔드의 고난이다. (탐정이죠 ㅋ).

### HTML
HTML은 웹 문서를 만들기 위해 만들어진 통칭 `마크업`언어이다. 최초의 `하이퍼링크`를 지원했었다.

> 마크업 언어란. 하이퍼텍스트 표시, 단락 표시, 줄 바꾸기, 글씨 등 문서의 시각적인 출력 형식을 나타내는 편집 명령이다. 간단하게 글의 뼈대라고 이해하면 쉽다.

### 웹 문서의 작성 수준 및 세대
**웹 서비스의 수준** 은 웹 문서를 어떤 방식으로 **제공** 하는지, 즉 웹 문서의 **작성 기술 수준** 에 따라 달라진다.

`수준`
- 수준 1 : HTML만을 이용해 웹 문서 작성
- 수준 2 : 클라이언트 스크립트를 이용한 웹 문서의 동적 생성
- 수준 3 : CGI를 이용한 웹 문서의 동적 생성
- 서버 스크립트와 데이터베이스 연동을 이용한 웹 문서의 동적 생성
- 웹 서버들의 연동을 이용한 웹 문서의 동적 생성

`세대`

- 세대 1 : 정적인 변하지 않는 웹 서비스
- 세대 2 : 유저의 상호작용 증가. 능동적인 웹 페이지. 동적 웹 서비스
- 세대 3 : 프론트엔드와 백엔드 구분 (분리)
- 모던 웹 서비스 : 규모가 커지기 시작한 웹 시스템의 발전.

> 이 부분은 찍히 나도 머리가 긁적인다. 아래에서 깊게 들어가보자..

#### 수준 1 | HTML 만을 이용한 웹 문서 작성
가장 기본적인 수준으로, HTML로만 작성된 웹 문서를 제공하는 것. 웹 서버에 방문한 모든 사용자는 웹 문서가 변경되지 않는한 **동일한 웹 문서** 를 전달 받는다.

#### 수준 2 | 클라이언트 스크립트를 이용한 웹 문서의 동적 생성
수준 1에 HTML 말고도 클라이언트 즉 `브라우저에서 실행되는 프로그래밍 코드(스크립트)`를 추가해서 동적인 기능을 포함한 웹 문서를 제공하는 것.

> 수준 1에서 자바스크립트를 이용해 웹 문서를 작성한다는 점 외에는 차이 없음.

#### 수준 3 | CGI 응용 프로그램을 이용한 웹 문서의 동적 생성
> CGI란? 서버 컴퓨터에서 웹 서버와 응용프로그램 사이의 데이터 전달을 위한 인터페이스.

서버 컴퓨터의 CGI 응용 프로그램은 CGI를 통해 웹 서버로부터 데ㅇ터를 전달받아 처리하고 그 결과를 웹 서버에 다시 전달 할 수 있음. CGI는 다양한 언어로 작성하며 동적 컨텐츠를 제공하는 것을 목표로 함. ODBC와 같은 인터페이스를 통해 DB 시스템과 연동할 수 있음. CGI의 범용성을 통해 웹 서비스가 폭발적으로 성장함.

CGI를 통한 동적 컨텐츠 예시

- 페이지에 오늘 접속자 수 표시
- 접속한 시간에 맞춰 '좋은아침입니다.', '맛있는 점심 되었나요?'등의 문구 출력
- 특정 사용자가 업로드한 게시글을 실시간으로 다른 사용자에게도 보여줌

CGI가 적용되며 정적인 웹 페이지를 주는 것이 아닌, 서버에서 HTML을 맞춤 생성해 반환하는 동적 웹 페이지가 가능해짐.

#### 수준 4 | 서버 스크립트와 데이터베이스 연동을 이용한 웹 서비스의 동적 생성
CGI를 이용함에 따라 웹 서버에 부하가 커져 이를 해결하기 위해 CGI대신 상대적으로 적은 자원을 사용하는 스크립트 언어가 사용되기 시작함.

별도의 독립된 프로그램으로 작성할 필요없이, HTML문서에 스크립트코드만 추가하면 되기 떄문에 개발이 간편하고 용이함, 특히 DB 서버와 연동하면 사용자별 맞춤 웹을 제공할 수 있어 이러한 서버 스크립트 엔진이 많이 활용되기 시작함. 대표적으로 PHP, JSP, ASP등이 있다. (코끼리는 산소 호흡기로 산다.)

#### 수준 5 | 웹 서버들의 연동을 이용한 웹 문서의 동적 생성

사용자에 따라 웹 서버는 그에 대한 정보를 다 가지고 있어야되는데 이는 여러 이유로 어렵다. 그래서 쓰는 방식이 각 기능마다 서버를 나누고 서버간의 연결을 하는 방식이다. 흔히 API라고 부름. 데이터를 주고받는 형식으로 `XML`과 `JSON`을 주로 사용한다. 최근 트랜드는 JSON을 주로 사용한다.

#### 세대 1 | 정적 웹 서비스
서버가 HTML 페이지 전체를 클라이언트에게 전송, 기능이 많지 않고 유저의 상호작용이 많이 요구되지 않음.

#### 세대 2 | 동적 웹 서비스
웹 서비스가 발전하며 정적인 페이지에서 유저의 상호작용이 많아지고 다이나믹한 요소들이 요구되며 자바스크립트 출현과 함께 나왔다. 웹서버에 HTML 뿐만 아니라 자바스크립트를 통해 서버와 필요한 데이터만을 주고 받음으로서 유저에게 더 많은 상호작용이 구현 가능하게 됨.

#### 세대 3 | 프론트엔드와 백엔드의 구분
정적인 HTML보다 동적인 기능이 주가 되며 자바스크립트가 주를 이루고 HTML과 CSS가 포함되는 형태.

기존의 방식과는 다르게 서버에서 웹 페이지 구성 요소를 매번 보내주는 것이 아니라 설계도와 같은 파일을 처음 한번만 전달하고 그 뒤에는 실시간으로 데이터만 통신하는 방식인 SPA(Single Page Application)이 등장함.

하나였던 웹 서비스가 서버단인 백엔드와 브라우저(클라이언트) 단인 프론트엔드로 나뉘며 각자 영역에 적합한 기술 위주로 사용하게 됨.

#### 모던 웹 | 규모가 커지기 시작한 웹 시스템의 발전
유저 인터렉션, 서비스의 복잡성, 사용자 데이터 량, 트래픽 등 여러 문제점들이 발생하였고, 이로 인해 웹 시스템 아키텍쳐의 발전이 이루어지게 되었으며 하나의 웹 서버에서 동작하던 프론트엔드와 백엔드가 각각의 서버로 분리되게 됨.

백엔드는 웹 서비스의 스케일이 엄청나게 커지고 분석해야하는 데이터의 양이 늘어남에 따라 시스템 구조가 복잡하게 발전하였음. MSA(Micro Service Architecture)등 새로운 아키텍쳐의 개념의 발전으로 벡엔드 서버는 각 기능마다 분리 세분화 되고 규모가 커지고 있음.

프론트엔드는 React, Vue, Anguler와 같은 자바스크립트 프레임워크 및 라이브러리의 발달로 보다 더 복잡한 기능을 쉽게 구현할 수 있게 되었음.


